import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/conversation.dart';
import '../models/message.dart';
import 'firebase_service.dart';

class MessagingService {
  static final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  static const String _conversationsCollection = 'conversations';
  static const String _messagesCollection = 'messages';

  /// Get or create a conversation between two users
  static Future<String?> getOrCreateConversation({
    required String otherUserId,
    required String otherUserName,
    String? otherUserAvatar,
  }) async {
    try {
      final currentUserId = FirebaseService.auth.currentUser?.uid;
      if (currentUserId == null) return null;

      // Generate conversation ID
      final conversationId = Conversation.generateId(currentUserId, otherUserId);

      // Check if conversation exists
      final docRef = _firestore.collection(_conversationsCollection).doc(conversationId);
      final doc = await docRef.get();

      if (!doc.exists) {
        // Create new conversation
        final now = DateTime.now();
        final conversation = Conversation(
          id: conversationId,
          participantIds: [currentUserId, otherUserId],
          participantNames: {
            currentUserId: 'Me', // Will be updated with actual name
            otherUserId: otherUserName,
          },
          participantAvatars: {
            currentUserId: null, // Will be updated
            otherUserId: otherUserAvatar,
          },
          unreadCount: {
            currentUserId: 0,
            otherUserId: 0,
          },
          createdAt: now,
          updatedAt: now,
        );

        await docRef.set(conversation.toFirestore());
      }

      return conversationId;
    } catch (e) {
      print('Error creating conversation: $e');
      return null;
    }
  }

  /// Send a text message
  static Future<bool> sendMessage({
    required String conversationId,
    required String receiverId,
    required String text,
    String? replyToId,
    String? mediaUrl,
    String? mediaType,
  }) async {
    try {
      final currentUserId = FirebaseService.auth.currentUser?.uid;
      if (currentUserId == null) return false;

      final now = DateTime.now();
      
      // Determine message type
      MessageType type = MessageType.text;
      String content = text;
      Map<String, dynamic>? metadata;
      
      if (mediaUrl != null && mediaType != null) {
        if (mediaType == 'image') {
          type = MessageType.image;
          content = mediaUrl;
          metadata = {'mediaType': mediaType};
        } else if (mediaType == 'voice') {
          type = MessageType.voice;
          content = mediaUrl;
          metadata = {'duration': 0};
        }
      }
      
      final message = Message(
        id: '', // Will be generated by Firestore
        conversationId: conversationId,
        senderId: currentUserId,
        senderName: 'Me', // TODO: Get from user profile
        type: type,
        content: content,
        timestamp: now,
        replyTo: replyToId,
        metadata: metadata,
      );

      // Add message
      await _firestore
          .collection(_messagesCollection)
          .add(message.toFirestore());

      // Update conversation
      final displayText = text.isEmpty ? 'ðŸ“· Photo' : text;
      await _updateConversationLastMessage(
        conversationId: conversationId,
        lastMessage: displayText,
        senderId: currentUserId,
        timestamp: now,
      );

      return true;
    } catch (e) {
      print('Error sending message: $e');
      return false;
    }
  }

  /// Send a music share (track, album, or playlist)
  static Future<bool> sendMusicShare({
    required String conversationId,
    required MessageType type,
    required String content,
    required Map<String, dynamic> metadata,
  }) async {
    try {
      final currentUserId = FirebaseService.auth.currentUser?.uid;
      if (currentUserId == null) return false;

      final now = DateTime.now();
      final message = Message(
        id: '',
        conversationId: conversationId,
        senderId: currentUserId,
        senderName: 'Me',
        type: type,
        content: content,
        metadata: metadata,
        timestamp: now,
      );

      await _firestore
          .collection(_messagesCollection)
          .add(message.toFirestore());

      await _updateConversationLastMessage(
        conversationId: conversationId,
        lastMessage: 'Shared a ${type.name}',
        senderId: currentUserId,
        timestamp: now,
      );

      return true;
    } catch (e) {
      print('Error sending music share: $e');
      return false;
    }
  }

  /// Get messages stream for a conversation
  static Stream<List<Message>> getMessages(String conversationId) {
    return _firestore
        .collection(_messagesCollection)
        .where('conversationId', isEqualTo: conversationId)
        .orderBy('timestamp', descending: true)
        .limit(100)
        .snapshots()
        .map((snapshot) =>
            snapshot.docs.map((doc) => Message.fromFirestore(doc)).toList());
  }

  /// Get conversations stream for current user
  static Stream<List<Conversation>> getConversations() {
    final currentUserId = FirebaseService.auth.currentUser?.uid;
    if (currentUserId == null) return Stream.value([]);

    return _firestore
        .collection(_conversationsCollection)
        .where('participantIds', arrayContains: currentUserId)
        .orderBy('updatedAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => Conversation.fromFirestore(doc))
            .toList());
  }

  /// Mark conversation as read
  static Future<void> markAsRead(String conversationId) async {
    return markMessagesAsRead(conversationId: conversationId);
  }

  /// Mark messages as read
  static Future<void> markMessagesAsRead({
    required String conversationId,
  }) async {
    try {
      final currentUserId = FirebaseService.auth.currentUser?.uid;
      if (currentUserId == null) return;

      // Get unread messages - simplified query to avoid index requirement
      final messagesQuery = await _firestore
          .collection(_messagesCollection)
          .where('conversationId', isEqualTo: conversationId)
          .where('isRead', isEqualTo: false)
          .get();

      // Mark as read - filter by senderId in-memory
      final batch = _firestore.batch();
      for (final doc in messagesQuery.docs) {
        final senderId = doc.data()['senderId'] as String?;
        if (senderId != null && senderId != currentUserId) {
          batch.update(doc.reference, {'isRead': true});
        }
      }

      // Reset unread count
      final convRef = _firestore
          .collection(_conversationsCollection)
          .doc(conversationId);
      batch.update(convRef, {
        'unreadCount.$currentUserId': 0,
      });

      await batch.commit();
    } catch (e) {
      print('Error marking messages as read: $e');
    }
  }

  /// Update typing status
  static Future<void> updateTypingStatus(
    String conversationId,
    bool isTyping,
  ) async {
    try {
      final currentUserId = FirebaseService.auth.currentUser?.uid;
      if (currentUserId == null) return;

      await _firestore
          .collection(_conversationsCollection)
          .doc(conversationId)
          .update({
        'typingStatus.$currentUserId': isTyping,
        'typingStatusUpdated.$currentUserId': Timestamp.now(),
      });
    } catch (e) {
      print('Error updating typing status: $e');
    }
  }

  /// Get typing status stream for other user
  static Stream<bool> getTypingStatus(
    String conversationId,
    String otherUserId,
  ) {
    return _firestore
        .collection(_conversationsCollection)
        .doc(conversationId)
        .snapshots()
        .map((doc) {
      if (!doc.exists) return false;
      final data = doc.data() as Map<String, dynamic>?;
      if (data == null) return false;
      
      final typingStatus = data['typingStatus'] as Map<String, dynamic>?;
      if (typingStatus == null) return false;
      
      return typingStatus[otherUserId] == true;
    });
  }

  /// Delete a message
  static Future<bool> deleteMessage(
    String conversationId,
    String messageId,
  ) async {
    try {
      await _firestore.collection(_messagesCollection).doc(messageId).delete();
      return true;
    } catch (e) {
      print('Error deleting message: $e');
      return false;
    }
  }

  /// Private helper: Update conversation's last message
  static Future<void> _updateConversationLastMessage({
    required String conversationId,
    required String lastMessage,
    required String senderId,
    required DateTime timestamp,
  }) async {
    try {
      final convRef = _firestore
          .collection(_conversationsCollection)
          .doc(conversationId);

      final doc = await convRef.get();
      if (!doc.exists) return;

      final conversation = Conversation.fromFirestore(doc);
      final currentUserId = FirebaseService.auth.currentUser?.uid;
      if (currentUserId == null) return;

      // Increment unread count for the other user
      final otherUserId = conversation.getOtherParticipantId(currentUserId);
      final newUnreadCount = Map<String, int>.from(conversation.unreadCount);
      newUnreadCount[otherUserId] = (newUnreadCount[otherUserId] ?? 0) + 1;

      await convRef.update({
        'lastMessage': lastMessage,
        'lastMessageSenderId': senderId,
        'lastMessageTime': Timestamp.fromDate(timestamp),
        'unreadCount': newUnreadCount,
        'updatedAt': Timestamp.fromDate(timestamp),
      });
    } catch (e) {
      print('Error updating conversation: $e');
    }
  }

  /// Get total unread messages count
  static Stream<int> getUnreadCount() {
    final currentUserId = FirebaseService.auth.currentUser?.uid;
    if (currentUserId == null) return Stream.value(0);

    return _firestore
        .collection(_conversationsCollection)
        .where('participantIds', arrayContains: currentUserId)
        .snapshots()
        .map((snapshot) {
      int total = 0;
      for (final doc in snapshot.docs) {
        final conversation = Conversation.fromFirestore(doc);
        total += conversation.getUnreadCountForUser(currentUserId);
      }
      return total;
    });
  }

  /// React to a message
  static Future<bool> reactToMessage(
    String messageId,
    String emoji,
  ) async {
    return toggleReaction(messageId: messageId, emoji: emoji);
  }

  /// Add or remove a reaction to a message
  static Future<bool> toggleReaction({
    required String messageId,
    required String emoji,
  }) async {
    try {
      final currentUserId = FirebaseService.auth.currentUser?.uid;
      if (currentUserId == null) return false;

      final messageRef = _firestore.collection(_messagesCollection).doc(messageId);
      final doc = await messageRef.get();
      
      if (!doc.exists) return false;

      final data = doc.data() as Map<String, dynamic>;
      final reactions = Map<String, dynamic>.from(data['reactions'] ?? {});
      
      if (reactions.containsKey(emoji)) {
        final users = List<String>.from(reactions[emoji] as List);
        if (users.contains(currentUserId)) {
          // Remove reaction
          users.remove(currentUserId);
          if (users.isEmpty) {
            reactions.remove(emoji);
          } else {
            reactions[emoji] = users;
          }
        } else {
          // Add user to reaction
          users.add(currentUserId);
          reactions[emoji] = users;
        }
      } else {
        // Create new reaction
        reactions[emoji] = [currentUserId];
      }

      await messageRef.update({'reactions': reactions});
      return true;
    } catch (e) {
      print('Error toggling reaction: $e');
      return false;
    }
  }

  /// Pin or unpin a conversation
  static Future<bool> togglePinConversation(String conversationId) async {
    try {
      final currentUserId = FirebaseService.auth.currentUser?.uid;
      if (currentUserId == null) return false;

      final convRef = _firestore.collection(_conversationsCollection).doc(conversationId);
      final doc = await convRef.get();
      
      if (!doc.exists) return false;

      final conversation = Conversation.fromFirestore(doc);
      final pinnedBy = List<String>.from(conversation.pinnedBy ?? []);
      
      if (pinnedBy.contains(currentUserId)) {
        pinnedBy.remove(currentUserId);
      } else {
        pinnedBy.add(currentUserId);
      }

      await convRef.update({'pinnedBy': pinnedBy});
      return true;
    } catch (e) {
      print('Error toggling pin: $e');
      return false;
    }
  }

  /// Mute a conversation
  static Future<bool> muteConversation(
    String conversationId,
    Duration? duration,
  ) async {
    try {
      final currentUserId = FirebaseService.auth.currentUser?.uid;
      if (currentUserId == null) return false;

      final convRef = _firestore.collection(_conversationsCollection).doc(conversationId);
      final doc = await convRef.get();
      
      if (!doc.exists) return false;

      final conversation = Conversation.fromFirestore(doc);
      final mutedBy = List<String>.from(conversation.mutedBy ?? []);
      
      if (!mutedBy.contains(currentUserId)) {
        mutedBy.add(currentUserId);
      }

      final mutedUntil = Map<String, dynamic>.from(conversation.mutedUntil ?? {});
      if (duration != null) {
        mutedUntil[currentUserId] = Timestamp.fromDate(DateTime.now().add(duration));
      } else {
        // Mute forever - set very far future date
        mutedUntil[currentUserId] = Timestamp.fromDate(DateTime(2099, 12, 31));
      }

      await convRef.update({
        'mutedBy': mutedBy,
        'mutedUntil': mutedUntil,
      });
      return true;
    } catch (e) {
      print('Error muting conversation: $e');
      return false;
    }
  }

  /// Unmute a conversation
  static Future<bool> unmuteConversation(String conversationId) async {
    try {
      final currentUserId = FirebaseService.auth.currentUser?.uid;
      if (currentUserId == null) return false;

      final convRef = _firestore.collection(_conversationsCollection).doc(conversationId);
      final doc = await convRef.get();
      
      if (!doc.exists) return false;

      final conversation = Conversation.fromFirestore(doc);
      final mutedBy = List<String>.from(conversation.mutedBy ?? []);
      final mutedUntil = Map<String, dynamic>.from(conversation.mutedUntil ?? {});
      
      mutedBy.remove(currentUserId);
      mutedUntil.remove(currentUserId);

      await convRef.update({
        'mutedBy': mutedBy,
        'mutedUntil': mutedUntil,
      });
      return true;
    } catch (e) {
      print('Error unmuting conversation: $e');
      return false;
    }
  }

  /// Delete a conversation and all its messages
  static Future<bool> deleteConversation(String conversationId) async {
    try {
      // Delete all messages in the conversation
      final messagesQuery = await _firestore
          .collection(_messagesCollection)
          .where('conversationId', isEqualTo: conversationId)
          .get();

      final batch = _firestore.batch();
      
      for (final doc in messagesQuery.docs) {
        batch.delete(doc.reference);
      }

      // Delete the conversation
      batch.delete(
        _firestore.collection(_conversationsCollection).doc(conversationId),
      );

      await batch.commit();
      return true;
    } catch (e) {
      print('Error deleting conversation: $e');
      return false;
    }
  }
}
